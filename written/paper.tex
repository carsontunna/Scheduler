\documentclass{article}

\usepackage[toc,page]{appendix} \usepackage{amsthm}
\usepackage{amsmath} \usepackage{amssymb} \usepackage{hyperref}

\pagestyle{fancy}

\setlength{\parindent}{0pt}

\title{TA Assignment Problem} \author{University of Calgary - CPSC 433
  - Fall 2013\\ \\Carson Tunna, Tyler Smith, Adam Thompson}
\date{October 2013}

\begin{document}

\maketitle\pagebreak

\tableofcontents\pagebreak

\section{Preamble}

For this problem we decided on OR-Tree based search and Set based
search. Our reasoning was as follows. We immediately had a solution
using an OR-Tree based model that covered every combination of TA
assignments to time slots. We figured using a greedy heuristic for our
$altern$ function we could likely come up with an optimal or slightly
sub optimal solution with relative ease. Our second choice as set
based search was very natural in that set based search allows for so
much flexibility. On top of this, the $F_{werth}$ function of set
based search parallels with the soft(and hard) constraints detailed in
the problem description. We were uninspired when we considered the
option of using an AND-Tree based search model simply because it's
difficult to apply a $div$ function to the structure of this problem.
Finally the main reason for selecting these search paradigms was
professor kremer confirming our instincts and telling us we made the
right choice.

\section{OR-Tree Based Search}

Let $L$ be the set of all tutorials or labs and $T$ be set of all
TA's. Then the problem is defined as follows:\\

\begin{enumerate}

\item $\forall x \in L$, $\exists y\in T$ such that instructs($y$,
  $l$).
  
\item All hard constraints are satisfied\footnote{See appendix}
  

\end{enumerate}

\subsection{Explanation of Model}

In the input we're given the following a set of time
slots\footnote{Time slots will be denoted $TS = (D, T)$ where $D \in
  \{MWF, MW, TR\}$}. These time slots consist of a set of days MWF,
MW, TR and a time in 24 hour format. Additionally were given a set of
TA's that have their own schedule that must be adhered to. We're
looking for the existence of as assignment(and if it exists, the
optimal solution) such that all time slots are filled with available
TA's. Enter OR-Tree based search.\\

The algorithm works as follows

\begin{enumerate}

\item Start with the empty set

\item Pick a TA with the greatest number of constraints to
  follow.\footnote{This helps us not get forced into a corner further
    down the tree}

\item For each time slot that the chosen TA is available to teach -
  add a branch to the root node. At the end of each branch are the
  nodes with a tuple that explains:
  
  \begin{enumerate}

  \item the goodness value of this pair
    
  \item the time slot

  \item the TA

  \end{enumerate}

\item Sort the branches from the root node by goodness value in
  ascending order\footnote{The largest goodness value possible is 0}


\item Set the left hand node to be your root node and recurse

\item When there are no more TA's available the left hand arm of the
  is a solution

\item While there is still time available for processing - Go back to
  the root of the tree and this time choose 2nd child of the $root = \emptyset$

\end{enumerate}

\subsection{Mathematical Description of the Model}

Let $L$ be the set of labs\\

Let $L'$ be the set of labs without a TA assignment yet\\

Let $T$ be the set of all TA's\\

Let $I : T \times L$ be a set of ordered pairs rerpresenting an
assignment of a TA to a lab.

\subsubsection{Defining the problem instance}

We defined our problem instance as follows

\[
pr = \langle (l_1, t_1), (l_2, t_2), ..., (l_n, t_n)  \rangle
\]

Where $(l_i, t_i) \in I$ and $pr : Prob = sequence$ $I$\\

States can be described by

\[
S = OTree(Prob, \{yes, no, ?\}, b_1 ... b_n)
\]

\subsubsection{Evaluating Solutions}

We define the function $f_{leaf} : S \times Env \rightarrow \mathbb{N}$

\[
f(s) = \sum_{t \in T} Cv(\langle (l_1, t_1) ... (l_n, t_n) \rangle)
\]

Where $Cv: Prob \rightarrow \mathbb{N}$ is a function that takes in a
sequence of assignmetns and returns the sum of contraints being violated.

\subsubsection{When is a branch solvable or unsolvable}\\

A $pr$ is unsolvable when

\begin{center}
  $Erw_{v,wt}((pr, ?),(pr, no)) \iff $(l, t) \in I \land violates-hard-constraint((l,t))$
\end{center}

I.e. for every assignment of a TA to a specific lab, a hard constraint
is violated.\\

A $pr$ is solved when\\

\begin{center}
  $Erw_{v,wt}((pr, ?),(pr, yes)) \iff \lnot Erw_{v,wt}((pr, ?),(pr,
  no)) \land |L'| = \emptyset$

\end{center}

I.e. the problem is not unsolvable and all the labs have been assigned
a TA.

\subsubsection{Branching Definition}

Define $Altern$ in the following way 

\begin{center}
  $Altern(s, s')$ such that $(|s| + 1 = |s'|) \land getLab(last(s')) \in
  L' \land getTA(last(s')) \in T$ 
\end{center}

Where $getLab() : I \times L \rightarrow L$ returns the lab from a
tuple in $I$. Similarlly for $getTA()$\\

I.e. the sequence $s'$ is longer than $s$ and we have assigned a TA to a lab
which hasn't had any assignment prior.

\begin{center}
  $Erw((pr, ?), (pr, ?, (pr_1, ?), (pr_2, ?), ... , (pr_n, ?)))$ if $pr_i$
  is generated out of assigning a valid TA to $pr_i$ such that this
  assignment doesn't violate any hard constants
\end{center}

\subsection{Demonstration of a small search instance}

















































\section{Set-Based Search}

\subsection{Explanation of Model}

The Set based search algorithm works as follows.

\begin{enumerate}

\item Start with an initial state $S_0$ of approximately fifty facts.
  This can be generate via random walks of our OR-Tree based tree

\item Take the best fact in $S_0$ and set it to max

\item Modify each fact by swapping TA assignments such that it
  enhances or doesn't change the $f_{werth}$ value of functions

\item Update the value of max

\item While there is still time left, go back to step 3


\end{enumerate}

\subsection{Mathematical Description of the Model}


Let a fact $F$ be a solution, albeit possibly very bad, to our problem
- $pr$.\\

Let a state $S \subseteq 2^F$.\\

Let $A = (S, T)$ where naturally $T$ is a relation defined $T: S
\times S$. We will elaborate further on $T$ below.\\

Define a function $Ext: A \rightarrow B$ where $A,B \subseteq F$. This
function will mutate a fact $A$ by swapping a TA assignment and time
slot thus creating a new fact $B$.\\

Definite exactly what $Ext$ does here\\

Let $T = \{(s,s') | \exist A \rightarrow B \in Ext , A \subseteq s ,
s' = (s - A) \cup B\}$\\

The search process is defined as $P = (A, Env, K)$ where $A$ is the
model defined above, $Env$ is the constraints put upon us and for this
instance, and all problems we will be solving in class, are static.\\

Let $K: S \times Env \rightarrow S and $K(s,e) = (s-A) \cup B where $A
\rightarrow B \in Ext$ and $A \subseteq s$ and $\forall A' \rightarrow
B' \in Ext.$ ... This definition is stupid. It's saything that
control function chooses the optimal swap for that fact.\\

$f_{werth}: 2^F \times 2^F \times Env \rightarrow \mathbb{N}$ and
defined as

\[
f_{werth}(x, y, e) = \sum_{i \in x}Cv(i, e) - \sum_{j \in y}Cv(j, e)
\]

where $Cv: S \times Env \rightarrow \mathbb{N}$. $Cv$ is a function
that totals the number of constraint violations a state violates.


\subsection{Demonstration of a small search instance}




















































































\pagebreak
\begin{appendices}

  \section*{Hard Constraints}

  //every TA is assigned at most MAX\_LABS labs\\ FORALL ta:TA .
  lab-count(ta) $\leq$ MAX\_LABS)\\

  //every TA is assigned at least MIN\_LABS labs (if the TA *has* a
  lab assignment)\\ FORALL ta:TA . lab-count(ta) $\not=$ 0 then
  lab-count(ta) $\geq$ MIN\_LABS)\\

  // no lab has more than one TA assigned to it\\ FORALL
  course:Course, lab:Lab $|$ has-lab(course,?,lab) . $\lnot$ EXISTS
  ta1,ta2:TA $|$ ta1$\not=$ ta2 . instructs(ta1,lab) $\land$
  instructs(ta2,lab)\\

  //every lab has a TA assigned to it\\ FORALL course:Course, lab:Lab
  $|$ has-lab(course,?,lab). EXITS ta:TA . instructs(ta,course,lab)\\

  //no TA is assigned simultanious labs\\ FORALL ta:TA, c1,c2:Course,
  b1,b2:Lab $|$ (c1=c2 => b1 $\not=$ b2) $\land$ instructs(ta,c1,b1)
  $\land$ instructs(ta,c2,b2) . $\lnot$ EXISTS t1,t2 $|$ at(c1,b1,t1)
  $\land$ at(c2,b2,t2) . conflicts(t1,t2)\\

  //no TA is assigned a lab that conflicts with his/her own
  courses\\ FORALL ta:TA, course:Course, lab:Lab $|$
  instructs(ta,course,lab) .\\ (($\lnot$ EXISTS c:Course, lec:Lecture
  $|$ taking(ta,c,lec) . EXISTS t1,t2 $|$ at(course,lab,t1) $\land$
  at(c,lec,t2)) . conflicts(t1,t2)) $\land$\\ (($\lnot$ EXISTS
  c:Course, b:Lab $|$ taking(ta,c,b) . EXISTS t1,t2 $|$
  at(course,lab,t1) $\land$ at(c,b,t2)) . conflicts(t1,t2)))\\

  where:\\ lab-count(TA) is a function that returns the number of labs
  a TA instructs.\\

\end{appendices}

\end{document}
